<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>


  <script>

    /*

    1. let const 用来声明变量, let和const都是块级作用域,let声明的变量只在let命令所在的代码块内有效,
    const 声明一个只读的变量,一旦声明,常量的值就不能改变.

    2. 箭头函数,这种方式,不需要function关键字,并且还可以省略return 关键字,
    同时,箭头函数内的this指向 函数 -- 定义-- 时候 所在的上下文对象,而不是函数执行时的上下文对象.
    */

  // for(var i = 0; i < 5; i++) {
  //   console.log(i)
  // }


     // 1.
    // {
    //   var a = 1;
    //   let b = 2;
    // }

    // console.log(a);
    // console.log(b)

    // const c = 3;
    // c = 4;

    //2.

    // () => a + 1
    // if(a>1) return;

    // function add() {
    //   return 1
    // }

    // var f = a => a + 1;
    // //D等价于
    // var f = function() {
    //   return a + 1;
    //   this.f = (a) => a + this.bar;
    // }

    // function foo() {
    //   this.bar = 1;
    //   this.f = (function(a) {
    //     return a + this.bar;
    //   }).bind(this);
    // }



    // 如果函数体内包含的语句多于一条, 就需要使用大括号将函数体扩起来, 使用return语句返回,
    // var f = (x, y) => {
    //   x ++;
    //   y --;
    //   return x + y;
    // }

    // 解构赋值:
    /*
    ES6允许按照一定的模式从 数组 和 对象 中提取值,对变量进行赋值,这被称为解构.
    */
    //数组结构
    //  let [a, b, c] = [1, 3, 4];
    //  console.log(a)

    // // 对象解构:
    // let name = 'lily';
    // let age = 3;
    // let person = {name, age};
    // console.log(person)

    // 对象解构的另一种形式:
    // let persons = { name: 'lily', age: 4 };
    // let {names, ages} = persons;
    // console.log(name)
    // console.log(age)

    // 函数的参数也可以解构赋值,例如:
    // 数组解构赋值:
    // function sum ([x, y]) {
    //   return x + y
    // };

    // sum([1, 2]);

    // 对象解构赋值:
    // function sumTwo({x, y}) {
    //    return x + y
    // }
    // sum({x: 1, y: 2})

    // 解构同样适用于嵌套结构的数组或者对象.
    // 嵌套结构的数组解构:
    // let [as, [bs], cs] = [1, [2], 3];
    // console.log(as)
    // console.log(bs)
    // console.log(cs)

    // // 嵌套结构的对象解构:
    // let {per: {m, n}, foos} = {per: {m: 1, n: 2}, foos: 'foo'}
    // console.log(m)
    // console.log(n)

    /*
     rest 参数:
     引入rest参数(形式为...变量名)用于获取函数的多余参数,以代替arguments对象的使用.
     rest参数是一个数组,数组中的元素是多余的参数.注意,rest参数之后不能再有其他的参数.
    */

   // 例如:

  //  function languages(lang, ...types) {
    //  console.log(types)
  //  }
  //  languages('js', 'java', 'python', '')

   /*
   6. 扩展运算符是三个点(...); 它将一个数组转为用逗号分隔的参数序列,类似于rest参数的逆运算.

   */
  //  function time(a,b,c) {
  //    return a + b + c
  //  }
  //  let numbers = [1, 2, 3];
  //  console.log(time(...numbers))
   // 扩展运算符还常用于合并数组以及与解构赋值结合使用,例如:
   // 合并数组:
  //  let arr1 = ['devin'];
  //  let arr2 = ['bawei', 'bawei1'];
  //  let arr3 = ['1','2',4];
  //  [...arr1, ...arr2, ...arr3]


   //与解构赋值结合:
  //  let [a2, ...rest] = ['a', 'b', 'c'];
  //  console.log(rest)

   // 扩展运算符还可以用于取出参数对象的所有可遍历属性,赋值到当前对象之中.例如:
  //  let bar = {a: 1, b: 2}
  //  let foo2 = {...bar};
  //  console.log(foo2)

  //  console.log(foo2 === bar)

  // 7. es6引入了class类这个概念,新的class写法让对象原型的写法更加清晰,也更像传统的面相对象编程语言的写法.

  // 定义一个类:

  // class Person {
  //   constructor(name, age) {
  //     this.name = name;
  //     this.age = age;
  //   }
  //   getName() {
  //     return this.name;
  //   }
  //   getAge() {
  //     return this.age;
  //   }
  // // }

  // // 根据类创建对象:
  // let person2 = new Person('Lily', 4);
  // // console.log(person2)

  // // class之间可以通过extends 关键字实现继承.

  // class Man extends Person {
  //   constructor(name, age) {
  //     super(name, age)
  //   }

  //   getGender() {
  //     return 'male'
  //   }
  // }

  // let man = new Man('jack', 23)
  // console.log(man)

  /*
   import  export
   es6实现了自己的模块化标准,es6模块主要功能主要由两个关键字构成,export 和 import. export用于规定模块对外暴露的接口,
   import 用于引入其他模块提供的接口,例如:
  */



  </script>
</body>
</html>